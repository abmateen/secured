
/*************************************/
/**  ***************/
/*** Author : Abdul Mateen ***********/
/*** Sponsoring Company : Additive Mobility / AddictiveTech Corp ***/
/** The Program is released under GPLv2 License ***/

/* Main file for process monitoring / controlling */#include <stdio.h>#include <stdlib.h>#include <sys/types.h>#include <errno.h>#include <sys/stat.h>#include <unistd.h>/* Custom includes */#include "pidof.h"#include "process.h"PROCESS_INFO *info;		// info global variablePROCESS_QUEUE *process_queue;	// process queue/* Extern variable for process list */extern char* process[256];extern char* notfile;/* Read proc and set the varios properties of structure * by reading proc directories it does that */PROCESS_INFO *getProcessInfobypid(pid_t pid){	/* Init process not allowed or if any error return of pidof is also 1 */	/* So Disable the 1 pid */        if ( pid == 1 ) return NULL;    PROCESS_INFO *tmp = (PROCESS_INFO *) malloc(sizeof(PROCESS_INFO));    struct stat vstat; // for checking proc dir uid    uid_t uid; // owner of the process        char *proc_name = (char *) calloc(50, sizeof(char));    char *data = (char*) calloc(256, sizeof(char));    char *proc_root = (char*) calloc(25,sizeof(char));        sprintf(proc_name, "/proc/%d/cmdline", pid);    sprintf(proc_root,"/proc/%d",pid);    FILE *proc_filesystem = fopen(proc_name, "r");            if (proc_filesystem == NULL) {	        fprintf(stderr, "Error:%s", strerror(errno));	return NULL;    }        // Process is running    // Getting uid of the owner running the process    stat(proc_root,&vstat);    uid  = vstat.st_uid;        int limit;    int index = 0; // For filling the string data    while ((limit = fgetc(proc_filesystem)) != EOF){      if ( limit == 0) limit = 0x20; // Treat ^@ in cmdline file as (space)      data[index++] = limit;          }        tmp->cmdline = data;    tmp->id = pid;    tmp->uid = uid;        fclose(proc_filesystem);    //   free(data);    //free(proc_root);    //free(proc_name);    return tmp;}/* First Initialize link list */PROCESS_QUEUE* initialize_queue(PROCESS_INFO* info_tmp){    PROCESS_QUEUE* tmp = (PROCESS_QUEUE*) malloc(sizeof(PROCESS_QUEUE));  tmp->info = info_tmp;  tmp->next = NULL;    return tmp;}/* Add to queue in order to manage the process and travers * through the queue and check every process after every n seconds */void add_to_queue(PROCESS_INFO* info, PROCESS_QUEUE* processqueue){  /* Temporary Address storage */  PROCESS_QUEUE* tmp;    if ( processqueue == NULL ){        processqueue = initialize_queue(info);    tmp = processqueue;    return;  }  printf("Not Empty Pushing into the list\n");  tmp = processqueue;  /* Running upto the current node */  while ( tmp->next != NULL ){        tmp=tmp->next;  }  /* Allocating space for the new node */  processqueue = (PROCESS_QUEUE*) malloc(sizeof(PROCESS_QUEUE));    /* Pushing the information */  processqueue->info = info;  processqueue->next = NULL;  /* Now assign previous list with the new address*/  tmp->next = processqueue;}/* Restarts the process if killed or died */int restart_process( PROCESS_INFO* info){  pid_t pid = info->id;  uid_t uid = info->uid;  pid_t fork_pid;  int status;  char *argv[256] = {"bash","-c"}; // to store the cmdline args  int index = 2; // should start filling argv from index 2    fprintf(stderr,"Spliting the things");  argv[index++] = strtok(info->cmdline," ");  while ( (argv[index] = strtok(NULL," ")) != NULL ) index++;    // Log this event in the log file  //FILE* file = fopen(notfile,"w");  fprintf(stderr,"\nRestarting %s please wait\n",info->cmdline);  if ( (fork_pid = fork()) == 0 ) {// fork success      setuid(uid);    execvp("bash",argv);    exit(0);     }   fprintf(stderr,"\n Reclaiming the pid\n");   info->id = fork_pid;   fprintf(stderr,"\n new pid is %d",info->id);    return 0;  }/* Check if the process is still running */int check_process_state(PROCESS_INFO* info){        pid_t pid = info->id;	char *proc_name = (char*) calloc(50,sizeof(char));	sprintf(proc_name, "/proc/%d/cmdline", pid);	FILE *proc_filesystem = fopen(proc_name, "r");    	 if (proc_filesystem == NULL) {		 //fprintf(stderr, "Error:%s", strerror(errno));		 //printf("Exited");		 //printf("Trying to restart");	   	         restart_process(info);		 //seteuid(info->uid);		 //execlp("ls",(char*)NULL);		 //system(info->cmdline);		 return 0;         }	 //seteuid(0);	 fclose(proc_filesystem);	 return 1;}/* Every n seconds queue is tranversed */void monitor_queue(PROCESS_QUEUE * queue){  PROCESS_INFO* info;  PROCESS_QUEUE* tmp;  int process_stat = 0;    //while ( 1 ){     tmp = queue;    while (  tmp != NULL ){        info = tmp->info;    process_stat = check_process_state(info);    tmp = tmp->next;        }    //sleep(5);  //}}PROCESS_QUEUE* init_process_queue(){    PROCESS_INFO *info;    PROCESS_QUEUE *implqueue;                       /* Filling the linked list or the queue with the pids*/        int i = 0;    info = getProcessInfobypid(get_pidof(process[i++]));    implqueue = initialize_queue(info);        while ( process[i] != NULL ){          printf("Proceses %s\n",process[i]);      info = getProcessInfobypid(get_pidof(process[i]));      if ( info == NULL ){	      printf("Error:Process  %s is not Running\n", process[i]);      }      else{      	add_to_queue(info, implqueue);      }            i++;        }       //monitor_queue(implqueue);    return implqueue;    }
